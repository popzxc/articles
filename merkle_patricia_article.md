_"Какого дьявола я должен помнить наизусть все эти чёртовы алгоритмы и структуры данных?"._

Примерно к этому сводятся комментарии большинства статей про прохождение технических интервью. Основной тезис, как правило, заключается в том, что всё так или иначе используемое уже реализовано по десять раз и с наибольшей долей вероятности заниматься этим рядовому программисту вряд ли придётся. Что ж, в какой-то мере это верно. Но, как оказалось, реализовано не всё, и мне, к сожалению (или к счастью?) реализовывать Структуру Данных всё-таки пришлось. Загадочное Modified Merkle Patricia Trie. Так как на хабре информации об этом дереве нет вообще, а на медиуме -- немногим больше, хочу поведать о том, что же это за зверь, и с чем его едят.

[КПДВ]

Для начала, давайте разберемся, что это за структура и зачем она вообще нужна. Делать мы будем это по частям.

<cut />

_Disclaimer: основным источником информации при реализации для меня являлись [Yellow paper](https://ethereum.github.io/yellowpaper/paper.pdf), а также исходные коды [parity-ethereum](https://github.com/paritytech/parity-ethereum) и [go-ethereum](https://github.com/ethereum/go-ethereum). Теоретической информации по поводу обоснования тех или иных решений было минимум, поэтому все выводы по поводу причин принятия тех или иных решений - мои личные. В случае, если я в чем-то заблуждаюсь - буду рад исправлениям в комментариях._

## Что это?

_Дерево_ - структура данных, представляющая собой связный ациклический граф. Тут всё просто, все с этим знакомы.

_Префиксное дерево_ - корневое дерево, в котором можно хранить пары ключ-значение за счёт того, что узлы делятся на два типа: те, что содержат часть пути (префикс), и конечные узлы, которые содержат хранимое значение. Значение присутствует в дереве тогда и только тогда, когда мы, используя ключ, можем пройти от корня дерева весь путь и в конце найти узел со значением.

_PATRICIA-дерево_ - это префиксное дерево, в котором префиксы бинарны - то есть, каждый узел-ключ хранит информацию об одном бите.

_Дерево Мёркла_ - это дерево хешей, построенное над какой-то цепочкой данных, агрегирующее эти самые хеши в один (корневой), хранящий информацию о состоянии всех блоков данных. То есть, корневой хеш - это эдакая "цифровая подпись" состояния цепи блоков. Используется эта штука активно в блокчейне, и подробнее про неё можно почитать [тут](https://habr.com/ru/company/bitfury/blog/346398/).

[картинка-демонстрация всех 4 деревьев]

Итого: Modified Merkle Patricia Trie (далее MPT для краткости) - это дерево хешей, хранящее пары ключ-значение, при этом ключи представлены в бинарном виде. А в чем именно заключается "Modified" мы узнаем чуть позже, когда будем обсуждать реализацию.

## Зачем это?

MPT используется в проекте Ethereum для хранения данных об аккаунтах, транзакциях, результатах их выполнения и прочих данных, необходимых для функционирования системы.
В отличие от Bitcoin, в котором состояние неявно и вычисляется каждым узлом самостоятельно, в эфире баланс каждого аккаунта (а также ассоциированные с ним данные) хранятся непосредственно в блокчейне. Более того, нахождение и неизменность данных должны быть обеспечены криптографически -- мало кто станет пользоваться криптовалютой, в которой баланс случайного аккаунта может измениться без объективных на то причин. 

Основной проблемой, с которой столкнулись разработчики `Ethereum` - это создание структуры данных, которая позволяет эффективно хранить пары ключ-значение и при этом обеспечивать верификацию хранимых данных. Так и появилось MPT.

## Как это?

MPT является префиксным PATRICIA-деревом, в котором ключами являются последовательности байтов.

Ребрами в данном дереве являются последовательности нибблов (половинок байтов). Соответственно, у одного узла может быть до шестнадцати потомков (соответствующих веткам от 0x0 до 0xF).

Узлы делятся на 3 вида:

- Branch node. Узел, используемый для ветвления. Содержит до от 1 до 16 ссылок на дочерние узлы. Также может содержать значение.
- Extension node. Вспомогательный узел, который хранит какую-то часть пути, общую для нескольких дочерних узлов, а также ссылку на branch node, лежащий далее.
- Leaf node. Узел, содержащий часть пути и хранимое значение. Является конечным в цепочке.

Как уже было упомянуто, MPT строится поверх другого kv-хранилища, в котором хранятся узлы в виде "ссылка" => "`RLP`-закодированный узел".

_И тут мы встречаемся с новым понятием: RLP. Если коротко - то это метод кодирования данных, представляющих собой списки или байтовые последовательности. Пример: `[ "cat", "dog" ] = [ 0xc8, 0x83, 'c', 'a', 't', 0x83, 'd', 'o', 'g' ]`. Вдаваться в подробности я особо не буду, и в реализации для этого использую готовую библиотеку, поскольку освещение еще и данной темы слишком раздует и без того немаленькую статью. Если же вам всё же интересно, более подробно вы можете почитать [тут](https://github.com/ethereum/wiki/wiki/RLP). Мы же ограничимся тем, что мы можем закодировать данные в `RLP` и раскодировать их обратно._

Ссылка на узел же определяется следующим образом: в случае, если длина `RLP`-закодированного узла составляет 32 или более байт, то ссылкой является `keccak`-хеш от `RLP`-представления узла. Если же длина меньше 32 байт, то ссылкой является само `RLP`-представление узла.
Очевидно, что во втором случае сохранять узел в базу данных не нужно, т.к. он целиком будет сохранен внутри родительского узла.

[ картинка с видами узлов ]

Комбинация трёх видов узлов позволяет эффективно хранить данные и в случае, когда ключей мало (тогда большая часть путей будет храниться в extension и leaf нодах, а branch-узлов будет мало), и в случае, когда узлов много (пути не будут храниться явно, а будут "собираться" во время прохода по branch нодам).

Полный пример дерева, использущего все виды узлов:

[ картинка с деревом ]

Как вы могли заметить, хранимые части путей имеют префиксы. Префиксы нужны для нескольких целей:
1. Чтобы отличать extension-узлы от leaf-узлов. 
2. Чтобы выравнивать последовательности, состоящие из нечетного количества нибблов.

Примеры путей с разными префиксами:

[ картинка с 4 возможными префиксами и объяснением ]

## Реализация

С теорией покончено, переходим к практике. Использовать будем лингва франка от мира IT, то бишь `python`.

Так как кода будет много, и для формата статьи многое придется сокращать и разделять, сразу же оставлю ссылку на [github](https://github.com/popzxc/merkle-patricia-trie).
В случае необходимости, там можно посмотреть на картину целиком.

Для начала определим интерфейс дерева, который мы хотим получить в итоге:

```python
class MerklePatriciaTrie:
    def __init__(self, storage, root=None):
        pass

    def root(self):
        pass

    def get(self, encoded_key):
        pass

    def update(self, encoded_key, encoded_value):
        pass

    def delete(self, encoded_key):
        pass
```

Интерфейс предельно прост. Доступные операции - получение, удаление, вставка и измененение (объединенные в update), а также получение корневого хеша.

В метод `__init__` будет передаваться хранилище - `dict`-like структура данных, в которой мы будем хранить узлы, а также `root` - "вершина" дерева. В случае, если в качестве `root` передан `None` - считаем, что дерево пустое и работаем с нуля.

_Ремарка: возможно, вам интересно, почему переменные в методах названы как `encoded_key` и `encoded_value`, а не просто `key`/`value`. Ответ прост: по спецификации все ключи и значения должны быть закодированы в `RLP`. Мы же этим себя утруждать не будем и оставим сие занятие на плечи пользователей библиотеки._

Однако, прежде чем мы приступим к реализации самого дерева, необходимо сделать две важных вещи:

1. Реализовать класс `NibblePath`, представляющий собой цепочки нибблов, чтобы не кодировать их вручную.
2. Реализовать класс `Node` и в рамках данного класса - `Extension`, `Leaf` и `Branch`.

### NibblePath

```python
class NibblePath:
    ODD_FLAG = 0x10
    LEAF_FLAG = 0x20

    def __init__(self, data, offset=0):
        self._data = data
        self._offset = offset

    def encode(self, is_leaf):
        output = []

        nibbles_len = len(self)
        is_odd = nibbles_len % 2 == 1

        prefix = 0x00
        prefix += self.ODD_FLAG + self.at(0) if is_odd else 0x00
        prefix += self.LEAF_FLAG if is_leaf else 0x00

        output.append(prefix)

        pos = nibbles_len % 2

        while pos < nibbles_len:
            byte = self.at(pos) * 16 + self.at(pos + 1)
            output.append(byte)
            pos += 2

        return bytes(output)

    def decode_with_type(data):
        """ Decodes NibblePath and its type from raw bytes. """
        is_odd_len = data[0] & NibblePath.ODD_FLAG == NibblePath.ODD_FLAG
        is_leaf = data[0] & NibblePath.LEAF_FLAG == NibblePath.LEAF_FLAG

        offset = 1 if is_odd_len else 2

        return NibblePath(data, offset), is_leaf

    def at(self, idx):
        """ Returns nibble at the certain position. """
        idx = idx + self._offset

        byte_idx = idx // 2
        nibble_idx = idx % 2

        byte = self._data[byte_idx]

        nibble = byte >> 4 if nibble_idx == 0 else byte & 0x0F

        return nibble

    def consume(self, amount):
        """ Cuts off nibbles at the beginning of the path. """
        self._offset += amount
        return self
```

### Node

Каюсь, пришлось использовать небольшой костыль *TODO*.

Leaf:

```python
class Leaf:
    def __init__(self, path, data):
        self.path = path
        self.data = data

    def encode(self):
        return rlp.encode([self.path.encode(True), self.data])
```

Extension:
```python
class Extension:
    def __init__(self, path, next_ref):
        self.path = path
        self.next_ref = next_ref

    def encode(self):
        next_ref = _prepare_reference_for_encoding(self.next_ref)
        return rlp.encode([self.path.encode(False), next_ref])
```

Branch:
```python
class Branch:
    def __init__(self, branches, data=None):
        self.branches = branches
        self.data = data

    def encode(self):
        branches = list(map(_prepare_reference_for_encoding, self.branches))
        return rlp.encode(branches + [self.data])
```


```python

class Node:
    # class Leaf(...)
    # class Extension(...)
    # class Branch(...)

    def decode(encoded_data):
        data = rlp.decode(encoded_data)

        if len(data) == 17:
            branches = list(map(_prepare_reference_for_usage, data[:16]))
            node_data = data[16]
            return Node.Branch(branches, node_data)

        path, is_leaf = NibblePath.decode_with_type(data[0])
        if is_leaf:
            return Node.Leaf(path, data[1])
        else:
            ref = _prepare_reference_for_usage(data[1])
            return Node.Extension(path, ref)

    def into_reference(node):
        encoded_node = node.encode()
        if len(encoded_node) < 32:
            return encoded_node
        else:
            return keccak_hash(encoded_node)
```

## MerklePatriciaTrie

Вспомогательные элементы готовы, переходим к самому вкусному.

### get

### update

### delete

### Остальное

## Результаты